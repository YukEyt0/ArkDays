# 图形学大作业说明文档

工程名称：ArkDays

学号：3210104430

姓名：陈飞扬

联系方式：504272207@qq.com

## 引言

### 设计要求
+ 基本要求
- [x] 具有基本体素（立方体、球、圆柱、圆锥、多面棱柱、多面棱台）的建模表达能力。
- [x] 具有基本三维网格导入导出功能（建议OBJ格式）。
- [x] 具有基本材质、纹理的显示和编辑能力。
- [x] 具有基本几何变换功能（旋转、平移、缩放等）。
- [x] 基本光照模型要求，并实现基本的光源编辑(如调整官员的位置，光强等参数)。
- [x] 能对建模后的场景进行漫游如Zoom In/Out, Pan, Orbit, Zoom To Fit等观察功能
- [x] 能够提供动画播放功能，能够提供屏幕取/保存功能

+ 额外要求
- [ ] 具有NURBBS曲面建模能力
- [x] 漫游时可以实时碰撞检测
- [ ] 光照模型细化，课任选实时阴影、causitc、位移纹理、全局光照明、辐射度、AO叠加等
- [ ] 采用HTML 5/Android移动平台实现
- [x] 构建了基于此引擎的完整三维游戏，具有可玩性
- [ ] 与增强现实应用结合
- [ ] 具有一定的对象表达能力，能够表达门、窗、墙等

### 设计说明

小组成员：陈飞扬

具体分工如下表所示
|小组成员|完成的主要工作|
|----|----|
|陈飞扬|实现基本体素的创建，建模与表达|
|陈飞扬|实现OBJ文件的导入导出|
|陈飞扬|实现材质以及纹理的添加，显示，编辑|
|陈飞扬|实现基本的集合变换功能|
|陈飞扬|实现基本光照模型以及光源编辑|
|陈飞扬|实现屏幕截取保存|
|陈飞扬|实现漫游时碰撞检测|
|陈飞扬|游戏玩法设计以及具体实现|
|陈飞扬|其他所有东西都是也我一个人写的|

## 运行说明

### 如何编译运行

#### Build and Compile
```shell
cmake -Bbuild . #(-G "MinGW Makefiles")
cmake --build build --config Release --parallel 8
```

#### Run
```shell
cd build/bin/Release
./final.exe
```

### 操作手册

本程序运行时有三种状态，分别是漫游模式，暂停模式，编辑模式

按```F1```键进行截图，截图存在```./build/screenshot/```中

按```ESC```键退出程序

程序开始运行时最初会加载所需的obj文件，以及所需的纹理和生成基本体素的顶点数据，加载会比较缓慢，全部加载完成后直接进入漫游模式，并且开始游戏

#### 漫游模式

按```P```键进入暂停模式

按```F2```键进入编辑模式

按```F5``` 键在第一人称，第三人称、无碰撞箱(<del>没有实现，虽然改一下也很简单</del>)视角下切换

按```W,A,S,D```分别水平向前后左右移动，按```Space```键上升，按```Shift```键下降

### 暂停模式

> 处于暂停模式下摄像头静止，静止移动，相机固定为俯视视角

按```P```键进入漫游模式

按```F2```键进入编辑模式

按```Left,Right```左右切换将要部署的干员

```鼠标左键```点击地图的可部署方块进入确认部署状态

确认部署状态下点击```鼠标左键```实现部署，点击```鼠标右键```退出确认部署状态

> 按照干员摆放规则部署干员

### 编辑模式

> 处于编辑模式下摄像头静止，静止移动，相机固定为漫游模式时的第一人称摄像机视角

按```F2```键进入漫游模式

>初始状态为编辑光源模式

>在编辑光源模式下可以鼠标拖动Gui悬浮窗中的各项参数改变平行光以及射光的各项参数

按住```Ctrl```键```鼠标左键```点击地图中的任意实体可以选中实体，进入实体编辑模式

>实体编辑模式下可以鼠标拖动Gui悬浮窗中的各项参数实现材质的编辑，纹理的切换与应用，物体的缩放旋转，以及选择导出当前物体的obj文件或者导出整个场景的obj文件

### 玩法说明

进入场景即为开始游戏，场景中初始的带有红框的方块为怪物出生点。怪物会根据事先规定的路径移动到带有蓝框的方块，那是我们的保护目标点，我们的游戏目标就是通过摆放我们的干员在特定位置，通过干员阻挡或者攻击怪物来消灭怪物，保护我们的目标点不受怪物入侵。<del>漏怪了也不会让游戏结束，游戏玩法实现部分比预想的要复杂十倍甚至九倍，最后只实现了一点基础的功能</del>

我们通过游戏操作界面的截图来说明游戏玩法：

![altText](.\build\screenshot\2024_0_4_13_23_22.bmp)

我们可以看到可部署干员有五种种类，分别是先锋、重装、医疗、术士、狙击。其中先锋和重装可以部署在草地上，并且可以阻挡敌方单位，其中先锋可以阻挡两个敌方单位，重装可以阻挡三个。医疗、术士、狙击单位可以摆放在高台上，也就是图中初始为木板的地块，其中医疗干员可以治疗我方单位，术士和狙击干员可以攻击地方单位，他们都是远程攻击，会发射投射物,投射物只会和要攻击的目标进行碰撞检测，检测到碰撞就说明攻击到了

我们的操作：暂停部署干员，漫游模式旁观游戏进行，等到所有的怪出完并且消失游戏视为结束了。游戏结束什么反应也没有，我们可以继续对场景进行漫游以及编辑

## 具体实现

### 具有基本体素（立方体、球、圆柱、圆锥、多面棱柱、多面棱台）的建模表达能力。
+ 实现方法

普通的体素不需要加载obj文件，我们根据一些数学计算可以得到所有的顶点数据，包括位置，法线，贴图的信息。

其实我们定义了创建一个任意边棱柱(台)的函数，但是我们在程序实现中只创造了一个上下边长比例为0.5的五棱台。

体素的建模有关的代码请查看```./src/basicshapes.h ./src/basicshapes.cpp```

所有的怪物建模都是基本体素

### 具有基本三维网格导入导出功能（建议OBJ格式）。
+ 实现方法

我们只读取obj文件中的v、vt、vn数据以及face数据，我们从文件中读取一行，判断第一个用空格隔开的字符串种类:
+ 为v，则向位置数组插入一项
+ 为vt，则向纹理数组插入一项
+ 为vn，则向法线数组插入一项
+ 为f，则根据f的数据读取位置数组，纹理数组，法线数组的相应数据组合成一个顶点，插入顶点数组。并根据f行数据定义的项数生成若干个三角形，记录他们的顶点编号后插入index数组

读取完文件中的所有内容则视为读取完毕

读取文件有关的代码请查看```./src/myobjectloader.h```

我们可以在上文提到过的地图编辑模式中选中物体导出obj文件，实现很简单：

1. 遍历顶点数组，按序输出位置，法线，纹理贴图数据
2. 遍历index数组，输出index数据

导出文件有关的代码请查看```./src/mymodel.cpp```
```./src/mymodel.h```

### 具有基本材质、纹理的显示和编辑能力。

具体纹理的加载我们使用了```./src/base/texture.h```
```./src/base/texture.cpp```
```./src/base/texture2d.h```
```./src/base/texture2d.cpp```
```./src/base/texture_cubemap.h```
```./src/base/textur_cubmap.cpp```

+ 我们在地图编辑模式打开纹理开关后，就可以在物体绘制的时候为着色器设置texture有关的Uniform变量。从而实现纹理的绘制。
+ 我们为所有的模型都加载了统一的初始材质，可以在地图编辑模式中修改选中物体的材质的各项参数

### 具有基本几何变换功能（旋转、平移、缩放等）。

关于几何变换，我们使用了```./src/base/transform.h```中定义的transform类，在课程作业的实验23都对于模型的几何变换以及移动做了详细的介绍。

我们所有模型的顶点数据在加载后都不会改变，改变的只有变换矩阵,我们本次实验中会动的模型只有我们选中旋转的物体，怪物以及投射物，还有我们的摄像头。

我们可以在编辑模式下选中任意体素去对他旋转平移缩放，都是改变transform类中的各项参数。
+ 实现方法

我们为每个Model类都配有一个transform类，在绘制一个Model的时候可以先对着色器设置从transform类中导出的位置矩阵，之后调用Model类中的Object子类的绘画方法。

### 基本光照模型要求，并实现基本的光源编辑(如调整官员的位置，光强等参数)。

本实验使用了冯氏光照模型，着色器代码可以查看```./src/sekai.cpp```中```Initshaders```函数
+ 实现方法
  
我们使用了```./src/base/light.h```中定义的平行光以及点光源，我们在实验5中已经详细地应用过了，这里也不在赘述

### 能对建模后的场景进行漫游如Zoom In/Out, Pan, Orbit, Zoom To Fit等观察功能

+ 实现方法
  
我们通过对于第一人称摄像机的上下左右前后移动以及拖动鼠标旋转来实现漫游，漫游的具体操作和课程实验3大同小异，漫游的方法可以参考操作手册

### 能够提供动画播放功能，能够提供屏幕取/保存功能

我们只实现了截屏功能，没有播放动画，截屏功能的实现文件参照```./src/screenshot.cpp```
```./src/screenshot.h```

+ 实现方法：
我们这里实现的截屏功能调用了windows库，所以是只有在windows操作系统环境下运行才能正常截屏，其实获取像素数据只是
```c
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glReadPixels(0, 0, width, height, GL_BGR, GL_UNSIGNED_BYTE, image);
```
调用了openGL库的方法，但是创建位图文件以及设置信息等用到了windows库

### 漫游时可以实时碰撞检测

我们在Model类中实现了一个AABB式的碰撞检测方法，检测this与我们输入参数代表的实体之间的碰撞。

具体的用法体现在检测子弹与目标的碰撞，检测我们漫游者与墙壁以及敌人干员模型的碰撞。

+ 实现方法

我们在碰撞检测方面将所有模型抽象为各种长方体，分别在x，y，z轴投影上检测他们是否有重合，三轴都有重叠意味着碰撞发生

至于怎么检测重合呢，我们可以读取两个物体的投影的边的顶点数据，记录他们的最大以及最小值，以x轴的重叠检测为例

```cpp
auto xaxis = glm::abs(std::max(max1.x,max2.x)-std::min(min1.x,min2.x)) < glm::abs(max1.x+max2.x-min1.x-min2.x);
```

两个物体的边长之和大于投影后线段的长度即为有重叠。这样实现应该和OpenGL-CN教程中的方法是等价的，但是更加的简单易读

### 构建了基于此引擎的完整三维游戏，具有可玩性

我们构建了一个类似于明日方舟的3D塔防游戏，具体的实现方法见下文

游戏流程在代码运行上的过程：

+ 输入阶段：
  1.   处理死亡的敌人与干员，将他们移除队列
  2.   程序处于运行状态：根据出怪时间表在对应地点产生怪物，对于所有怪物处理他们的移动：处于移动状态的怪物向下一个检查点移动，处于阻挡状态的怪物不会移动。之后处理怪物与干员的相互攻击，所有的攻击会被记录，并且在伤害结算阶段统一结算。在伤害结算阶段，结算处于命中状态的伤害，近战伤害造成后立刻进入命中状态，远程伤害造成后会创建一个投射物，当投射物命中敌人才会让该伤害进入命中状态，伤害结算根据攻防决定减少的生命值，单位生命值小于0则进入死亡状态。
  3.   程序处于暂停状态：可以摆放干员，我们将屏幕根据地图格子划分为不同区域，我们绘制了一个以特定编号为颜色值的特殊缓冲，并且从该缓冲中读取像素点来判断我们选中的是哪个地块，之后检查是否符合部署条件，最后部署
+ 绘制阶段：
  1. 我们绘制所有已经摆放的干员，存活的敌人，投射物，并且计算投射物的移动。 

关于干员的相关的代码，查看```./src/operator.h```
```./src/operator.cpp```

关于敌人相关的代码，查看```./src/enemy.h```
```./src/enemy.cpp```

关于实现游戏逻辑部分的代码，查看```./src/sekai.cpp```
```./src/sekai.h```

游戏性上对于作业要求来说好像用力过猛了，所以也就不过多介绍了

### 模型的管理

我们定义了一个MyModel类，管理绘制一个3d模型所需要的全部数据，包括顶点数据，变换矩阵，材质以及纹理。

详情参见```./src/mymodel.cpp```
```./src/mymodel.h```